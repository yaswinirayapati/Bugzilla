from flask import Flask, request, jsonify
from flask_cors import CORS
import threading
import os
import time
from dotenv import load_dotenv
from jira import JIRA
import requests
from datetime import datetime

load_dotenv()

# Load environment variables
JIRA_EMAIL = os.getenv("JIRA_EMAIL")
JIRA_API_TOKEN = os.getenv("JIRA_API_TOKEN")
JIRA_URL = os.getenv("JIRA_URL")
JIRA_PROJECT_KEY = os.getenv("JIRA_PROJECT_KEY")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY", "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")

# Initialize JIRA
try:
    jira = JIRA(
        server=JIRA_URL,
        basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN)
    )
    # Test connection
    project = jira.project(JIRA_PROJECT_KEY)
    print(f"‚úÖ Connected to JIRA. Project: {project.name}")
except Exception as e:
    print(f"‚ùå Failed to connect to JIRA: {e}")
    jira = None

ERROR_KEYWORDS = ["ERROR", "Exception", "Failed"]


def get_ai_suggestion(error_line):
    prompt = f"What could be the cause and possible fix for this error: {error_line}"
    
    try:
        headers = {
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": "qwen/qwen-2.5-72b-instruct",
            "messages": [
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 300,
            "temperature": 0.3
        }
        
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
            json=data,
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            if "choices" in result and len(result["choices"]) > 0:
                return result["choices"][0]["message"]["content"].strip()
            else:
                return "AI analysis failed: Invalid response format"
        else:
            error_detail = response.text if response.text else f"HTTP {response.status_code}"
            return f"AI analysis failed: {error_detail}"
            
    except requests.exceptions.Timeout:
        return "AI analysis failed: Request timeout"
    except requests.exceptions.RequestException as e:
        return f"AI analysis failed: Network error - {str(e)}"
    except Exception as e:
        return f"AI analysis failed: {str(e)}"


def create_jira_ticket(error_line, suggestion):
    if not jira:
        print("‚ùå JIRA not connected, cannot create ticket")
        return None
        
    try:
        # Determine error type and severity
        error_lower = error_line.lower()
        
        if any(word in error_lower for word in ['timeout', 'connection refused']):
            error_type = "Connection Error"
            severity = "Medium"
        elif any(word in error_lower for word in ['null pointer', 'undefined', 'index out of range']):
            error_type = "Runtime Error"
            severity = "High"
        elif any(word in error_lower for word in ['authentication', 'unauthorized', 'forbidden']):
            error_type = "Security Error"
            severity = "Critical"
        elif any(word in error_lower for word in ['database', 'sql', 'query']):
            error_type = "Database Error"
            severity = "High"
        else:
            error_type = "General Error"
            severity = "Medium"
        
        # Map severity to JIRA priority
        priority_mapping = {
            "Critical": "Highest",
            "High": "High", 
            "Medium": "Medium",
            "Low": "Low"
        }
        
        jira_priority = priority_mapping.get(severity, "Medium")
        
        issue_dict = {
            'project': {'key': JIRA_PROJECT_KEY},
            'summary': f"üö® {error_type}: {error_line[:50]}...",
            'description': f"""
# Auto-Detected Log Error

## Error Details
- **Error Message**: {error_line}
- **Error Type**: {error_type}
- **Severity**: {severity}
- **Detected At**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## AI Suggestion
{suggestion}

---
*This ticket was automatically generated by the Bug Tester AI system.*
            """,
            'issuetype': {'name': 'Bug'},
            'priority': {'name': jira_priority},
            'labels': [error_type.replace(' ', '-'), 'auto-generated']
        }
        
        issue = jira.create_issue(fields=issue_dict)
        return issue
        
    except Exception as e:
        print(f"Failed to create JIRA ticket: {e}")
        return None


def monitor_log_file(log_file_path):
    print(f"Monitoring log file: {log_file_path}")
    try:
        with open(log_file_path, 'r') as f:
            # Move to end of file
            f.seek(0, 2)
            while True:
                line = f.readline()
                if not line:
                    time.sleep(1)
                    continue
                if any(keyword in line for keyword in ERROR_KEYWORDS):
                    print("Error detected:", line.strip())
                    suggestion = get_ai_suggestion(line)
                    issue = create_jira_ticket(line, suggestion)
                    if issue:
                        print("Created JIRA ticket:", issue.key)
                    else:
                        print("Failed to create JIRA ticket")
    except FileNotFoundError:
        print(f"Log file not found: {log_file_path}")
    except Exception as e:
        print(f"Error monitoring log file: {e}")


# --- Flask API for log upload ---
app = Flask(__name__)
CORS(app)  # Allow frontend from port 5500

# Dummy log monitoring function (replace with your real one)
def monitor_log():
    log_path = os.getenv("LOG_FILE_PATH", "C:/Users/BADE.HARSHITHA/bug-tester-ai/logs/app.log")
    print(f"Monitoring log file: {log_path}")
    while True:
        time.sleep(5)  # Simulate log monitoring

# Start monitoring logs in the background
threading.Thread(target=monitor_log, daemon=True).start()

@app.route('/upload-log', methods=['POST'])
def upload_log():
    if 'log' not in request.files:
        return jsonify({"error": "No file uploaded"}), 400

    file = request.files['log']
    content = file.read().decode('utf-8')
    return jsonify({"message": "Log received", "lines": content.splitlines()})

if __name__ == '__main__':
    app.run(port=5001)


# Optional: For testing standalone
if __name__ == "__main__":
    log_path = os.getenv("LOG_FILE_PATH", "sample.log")
    monitor_log_file(log_path)
